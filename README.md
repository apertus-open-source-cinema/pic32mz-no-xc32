# pic32mz without xc32
This is a effort to use pic32mz without microchips `xc32` compiler.
Currently this focuses on the pic32mz2048ecg100.

## General overview
Getting assembly or basic c code running on the pic32mz using mainline gcc and binutils is fairly simple, 
it just requires compiling for `mipsel` and for c some simple startup code that sets up the stackpointer.

This however results in fairly slow execution, as the l1 cache is not initialized and is mostly incompatible with existing code written against `xc32`.

To remedy this the startup code from the `xc32` compiler is taken, parts in assembly form (as part of `startup.S`) and parts as binary form `libpic32.a`. 
I am fairly sure, everything to build `libpic32.a` is available in source form aswell and it could be built from these in the future. However there are more interesting problems to solve first.

The `xc32` compiler also provides some additional features to make programming the `pic32mz` easier. These include the `config` pragma to configure the `DEVCFG{0,1,2,3}` registers and 
custom attributes for interrupts service routines (`ISR`s). These are currently implemented as following.

### DEVCFG{0,1,2,3} registers
To configure these registers one simply needs to put the right values at the respective addresses (`0xBFC0FFC{0,4,8,C}`).
This is currently done by placing the 32 bit configuration word for each of the registers into a special section (`.devcfg{0,1,2,3}`). 
The contents of these sections are put at the right location by the linker script. To put a configuration word into on of these sections the following assembly snippet can be used:
```
.section .devcfg0,"ax",@progbits
.word 0xfffffbff
.text
```
To translate the `config` pragmas into these 32 bit words either the pic32mz2048ecg100 datasheet can be used, or they can be read out from a programmed pic32mz, using for example `pic32prog`.
### ISRs
Interrupts are a bit more tricky and don't seem to work currently. Whats currently understood is, that (atleast when defining ISRs from c code) each of the interrupts is put into the `.vectors` section. Located at `0x9D000200` is then a interrupt vector table, where each entry jumps to the ISR defined in the c code (if it exists) or a default handler. The offset to the correct table entry for each interrupt is programmed into the interrupt controller (using the registers at `0xBF810540` onwards).
When using the `xc32` compiler the initialization of these done using the `__pic32_data_init` function using the `.dinit` section generated by the linker.
This work currently does this by manually writing the interrupt vector table to jump to the correct c function. By giving the correct name and section to these entries the linker script can automatically put them at the correct location and set the `__vector_offset_$N` symbols to the correct offset. These symbols are then used to configure the interrupt controller (using the code generated by the `gen_interrupt_setup_code.py` script).

However currently something seems to be missing / wrong as the ISRs seem to never be entered. This could have many reasons, some obvious deviations from the `xc32` code are
- a vastly different function prelude / epilogue is generated by `xc32` for the ISRs compared with the one generated for a normal c function.
- interrupt priority and the shadow register annotation are completely ignored
- a `xc32` generated elf contains sections that are supposed to land at `0xBF810540` (the interrupt controller offset configuration), however these don't seem to land in the `.hex` file. (I would expect them to land at `0x1F810540` according to the pic32mc datasheet p.63f)
- a major difference between the `hex` file generated by the `xc32` toolchain and one generated by the mainline one is, that the `xc32` one seems to use physical addresses and the mainline one virtual addresses. This however this seems to work atleast for simple c code examples.

## license notices
`libpic32.a`, `Vendor/*`, parts of `p32MZ2048ECG100.{ld, S}` and parts of `startup.S`:
```
 * Copyright (c) 2019, Microchip Technology Inc. and its subsidiaries ("Microchip")
 * All rights reserved.
 * 
 * This software is developed by Microchip Technology Inc. and its
 * subsidiaries ("Microchip").
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are 
 * met:
 * 
 * 1.      Redistributions of source code must retain the above copyright
 *         notice, this list of conditions and the following disclaimer.
 * 2.      Redistributions in binary form must reproduce the above 
 *         copyright notice, this list of conditions and the following 
 *         disclaimer in the documentation and/or other materials provided 
 *         with the distribution.
 * 3.      Microchip's name may not be used to endorse or promote products
 *         derived from this software without specific prior written 
 *         permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 * SHALL MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
```
